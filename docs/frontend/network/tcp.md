---
title: TCP
description: 介绍什么是TCP
category: network
tags:
  - network
  - TCP
  - UDP
---

# TCP

## TCP/IP网络模型

**TCP/IP网络模型**是互联网最基本的通信模型，它是由两个协议簇（Protocol Suite）组成：`TCP`（传输控制协议）和 `IP`（网际协议）。
共分为四层，分别为：

1. 应用层（Application Layer）：处理特定应用程序的协议，例如 `HTTP`、`FTP`、`SMTP` 等。

2. 传输层（Transport Layer）：提供端到端的接口，负责向两台主机中的应用程序提供通信服务，常用协议有 `TCP`、`UDP` 等。

3. 网络层（Internet Layer）：处理网络上的流量路由和寻址，主要包括 `IP` 协议。

4. 数据链路层（Link Layer）：负责处理网络物理设备和网络之间的数据传输，常用协议有 `Ethernet`、`PPP` 等。

`TCP/IP` 网络模型与 `OSI` 网络模型相似，但是它们之间存在一些差异。`TCP/IP` 网络模型是一个更加实用的模型，主要应用于互联网和局域网等通信网络。

## TCP 三次握手

1. 第一次握手：客户端向服务器发送 `SYN` 包（`SYN=j`）并进入 `SYN_SENT` 状态，等待服务器确认。

2. 第二次握手：服务器收到客户端的 `SYN` 包后，确认客户端的 `SYN`（`ACK=j+1`），并向客户端发送一个自己的 `SYN` 包（`SYN=k`
   ），即 `SYN+ACK` 包，此时服务器进入 `SYN_RECV` 状态。

3. 第三次握手：客户端收到服务器的 `SYN+ACK` 包后，向服务器发送确认包 `ACK`（`ACK=k+1`
   ），此包发送完毕，客户端和服务器进入 `ESTABLISHED` 状态，`TCP` 连接建立成功。

:::warning
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
:::


## TCP 四次挥手

1. 客户端发送连接释放报文段（`FIN=1，seq=x`），并进入 `FIN_WAIT_1` 状态，等待服务端确认。

2. 服务端收到连接释放报文段后，发送确认报文段（`ACK=1，ack=x+1`），进入 `CLOSE_WAIT` 状态，等待客户端发送连接释放报文段。

3. 如果服务端有要发送的数据，会先将数据发送完毕，然后发送连接释放报文段（`FIN=1，seq=y`），进入 `LAST_ACK` 状态，等待客户端确认。

4. 客户端收到连接释放报文段后，发送确认报文段（`ACK=1，ack=y+1`），进入 `TIME_WAIT` 状态，等待 `2MSL` 后进入 `CLOSED`
   状态。`2MSL` 是为了确保服务端收到了确认报文段，如果没有收到则会重传连接释放报文段。

5. 服务端收到客户端发送的确认报文段后，进入 `CLOSED` 状态，释放连接。

6. 客户端等待 `2MSL` 后，确认服务端已经收到了确认报文段，进入 `CLOSED` 状态，释放连接。

:::tip
总结来说，`TCP` 四次挥手过程的目的是为了确保客户端和服务端都知道连接已经关闭，并且在关闭连接之前，双方都有机会传递完所有的数据。在这个过程中，双方都会进入一些状态来等待对方的确认和数据传输。
:::

## TCP 和 UDP 的区别

`TCP` 和 `UDP` 是传输层协议，用于在网络上传输数据，但它们之间有几个重要的区别。

1. 可靠性：`TCP`
   是可靠的，它确保数据包的正确性和完整性。它使用三次握手建立连接，确认数据包的接收，并保证数据包的顺序。而 `UDP`
   则是不可靠的，因为它不保证数据包的正确性、完整性和顺序。

2. 连接：`TCP` 是面向连接的协议，建立连接、数据传输和释放连接都需要经过一定的过程。`UDP`
   则是无连接的，发送端只是直接把数据包发送给接收端，不需要连接的建立和释放过程。

3. 效率：`UDP` 比 `TCP` 快，因为它不需要建立连接和保证数据包的可靠传输。但是，由于 `UDP` 不保证数据包的可靠性和完整性，所以需要应用程序来负责处理这些问题。

4. 应用场景：`TCP` 适用于需要可靠数据传输的应用程序，如文件传输、电子邮件、Web应用程序等。`UDP` 适用于需要快速数据传输的应用程序，如视频、音频、游戏等。

总之，`TCP` 提供了可靠性和顺序控制，而 `UDP` 提供了快速传输和更少的开销。选择哪种协议取决于应用程序的需求和特点。

## TCP 粘包

`TCP` 粘包是指：发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。也就是说，多个数据包粘合在了一起形成了一个粘包。

**出现原因：**

1. 发送方缓存数据包过多或传输速度过快，导致多个数据包一次性发送。

2. 接收方读取数据包的方式不当，比如采用固定长度的方式读取数据，而不考虑数据包之间的边界问题。

3. 网络拥塞、传输延迟

**解决对策：**

1. 定长包：发送方在发送数据时，将每个数据包的大小固定为一个定值，接收方按照这个固定的大小来接收数据包。

2. 分隔符：发送方在每个数据包的结尾添加一个特殊的分隔符，接收方在接收数据时按照这个分隔符来区分不同的数据包。

3. 包头+包体：在每个数据包中添加包头和包体，包头用来描述包体的长度和其他属性，接收方在接收数据时先读取包头，然后根据包头中的长度信息来读取包体。

4. 应用层协议：应用层协议可以自定义数据的格式，发送方和接收方都按照这个协议来解析数据包。
